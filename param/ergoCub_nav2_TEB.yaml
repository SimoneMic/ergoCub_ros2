bt_navigator:
  ros__parameters:
    use_sim_time: True
    global_frame: map
    robot_base_frame: virtual_unicycle_base #projection   #base_link
    odom_topic: /estimated_odom
    #default_bt_xml_filename: "navigate_w_replanning_and_recovery.xml"
    bt_loop_duration: 10
    default_server_timeout: 40
    enable_groot_monitoring: True
    groot_zmq_publisher_port: 1666
    groot_zmq_server_port: 1667
    # 'default_nav_through_poses_bt_xml' and 'default_nav_to_pose_bt_xml' are use defaults:
    # nav2_bt_navigator/navigate_to_pose_w_replanning_and_recovery.xml
    # nav2_bt_navigator/navigate_through_poses_w_replanning_and_recovery.xml
    # They can be set here or via a RewrittenYaml remap from a parent launch file to Nav2.
    plugin_lib_names:
    - nav2_compute_path_to_pose_action_bt_node
    - nav2_compute_path_through_poses_action_bt_node
    - nav2_smooth_path_action_bt_node
    - nav2_follow_path_action_bt_node
    - nav2_spin_action_bt_node
    - nav2_wait_action_bt_node
    - nav2_back_up_action_bt_node
    - nav2_drive_on_heading_bt_node
    - nav2_clear_costmap_service_bt_node
    - nav2_is_stuck_condition_bt_node
    - nav2_goal_reached_condition_bt_node
    - nav2_goal_updated_condition_bt_node
    - nav2_globally_updated_goal_condition_bt_node
    - nav2_is_path_valid_condition_bt_node
    - nav2_initial_pose_received_condition_bt_node
    - nav2_reinitialize_global_localization_service_bt_node
    - nav2_rate_controller_bt_node
    - nav2_distance_controller_bt_node
    - nav2_speed_controller_bt_node
    - nav2_truncate_path_action_bt_node
    - nav2_truncate_path_local_action_bt_node
    - nav2_goal_updater_node_bt_node
    - nav2_recovery_node_bt_node
    - nav2_pipeline_sequence_bt_node
    - nav2_round_robin_node_bt_node
    - nav2_transform_available_condition_bt_node
    - nav2_time_expired_condition_bt_node
    - nav2_path_expiring_timer_condition
    - nav2_distance_traveled_condition_bt_node
    - nav2_single_trigger_bt_node
    - nav2_is_battery_low_condition_bt_node
    - nav2_navigate_through_poses_action_bt_node
    - nav2_navigate_to_pose_action_bt_node
    - nav2_remove_passed_goals_action_bt_node
    - nav2_planner_selector_bt_node
    - nav2_controller_selector_bt_node
    - nav2_goal_checker_selector_bt_node
    - nav2_controller_cancel_bt_node
    - nav2_path_longer_on_approach_bt_node
    - nav2_wait_cancel_bt_node
    - nav2_spin_cancel_bt_node
    - nav2_back_up_cancel_bt_node
    - nav2_drive_on_heading_cancel_bt_node

bt_navigator_rclcpp_node:
  ros__parameters:
    use_sim_time: True

bt_navigator_navigate_through_poses_rclcpp_node:
  ros__parameters:
    use_sim_time: True

bt_navigator_navigate_to_pose_rclcpp_node:
  ros__parameters:
    use_sim_time: True

controller_server:
  ros__parameters:
    use_sim_time: True
    controller_frequency: 2.0    #20.0
    min_x_velocity_threshold: 0.0001
    min_y_velocity_threshold: 0.0001
    min_theta_velocity_threshold: 0.0001
    failure_tolerance: 0.0    #0.5
    odom_topic: /estimated_odom
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"] 
    controller_plugin_types: ["teb_local_planner::TebLocalPlannerROS"]  #only for TEB
    controller_plugins: ["FollowPath"]

    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5   #0.5
      movement_time_allowance: 20.0
    
    general_goal_checker:
      stateful: True
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.5
      yaw_goal_tolerance: 2.1  #0.5 -> don't care about theta atm

    #TEB
    FollowPath:
      plugin: teb_local_planner::TebLocalPlannerROS

      teb_autosize: 1.0
      dt_ref: 0.3   #0.3    #Determines the desired resolution of the trajectory: small values lead to a fine resolution and thus a better approximation of the kinodynamic model, but many points must be optimized (major impact on optimization time). Too high values (> 0.6s) can lead to trajectories that are not feasible anymore due to the poor approximation of the kinodynamic model
      dt_hysteresis: 0.03   #0.1 #Hysteresis for automatic resizing depending on the current temporal resolution, usually approx. 10% of dt_ref is recommended 
      min_samples: 30  #3 -> 30    #Minimum number of samples (should be always greater than 2) 
      max_samples: 1000  #500
      global_plan_overwrite_orientation: False  #False   #Overwrite orientation of local subgoals provided by the global planner (since they often provide only a 2D path) 
      allow_init_with_backwards_motion: False
      max_global_plan_lookahead_dist: 4.0   # 3.0   #Limits the distance to the virtual goal (along the global plan) and thus the number of poses subject to optimization (temporal distance between poses approx dt_ref seconds). But the length is also bounded by the local costmap size 
      force_reinit_new_goal_dist: 1.0   #1.0    #Reinitialize the trajectory if a previous goal is updated with a separation of more than the specified value in meters (skip hot-starting) 
      global_plan_viapoint_sep: -0.1   #0.3 -> 1.0 If positive, via-points are extrected from the global plan (path-following mode). The value determines the resolution of the reference path (min. separation between each two consecutive via-points along the global plan, if negative: disabled). Refer to parameter weight_viapoint for adjusting the intensity. 
      global_plan_prune_distance: 3.0 #1.0
      feasibility_check_no_poses: 2 #2  -> 4
      publish_feedback: False
      exact_arc_length: False   #If true, the planner uses the exact arc length in velocity, acceleration and turning rate computations (-> increased cpu time), otherwise the Euclidean approximation is used. 
          
      # Robot
              
      max_vel_x: 0.26    #0.26
      max_vel_theta: 1.0  #1.0
      max_vel_y: 0.0    #0.0  #Maximum strafing velocity of the robot (should be zero for non-holonomic robots!) 
      acc_lim_x: 2.5    #2.5
      acc_lim_y: 0.0
      acc_lim_theta: 3.2    #3.2

      footprint_model: # types: "point", "circular", "two_circles", "line", "polygon"
        type: "circular"
        radius: 0.4 # for type "circular"

      # GoalTolerance
      xy_goal_tolerance: 0.5  #0.2  #Allowed final euclidean distance to the goal position in meters 
      yaw_goal_tolerance: 3.14    #0.2  #Allowed final orientation error in radians         
      free_goal_vel: False      #Remove the goal velocity constraint such that the robot can arrive at the goal with maximum speed 
      
      # Obstacles
          
      min_obstacle_dist: 0.5    #0.5
      inflation_dist: 0.6   #Buffer zone around obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect). Also refer to the weight weight_inflation. 
      include_costmap_obstacles: True       #Specify if obstacles of the local costmap should be taken into account. Each cell that is marked as obstacle is considered as a point-obstacle. Therefore do not choose a very small resolution of the costmap since it increases computation time. In future releases this circumstance is going to be addressed as well as providing an additional api for dynamic obstacles. 
      costmap_obstacles_behind_robot_dist: 1.0    #1.0 #Limit the occupied local costmap obstacles taken into account for planning behind the robot (specify distance in meters). 
      obstacle_poses_affected: 20   #30 #Number of nearest neighbors on the trajectory taken into account (increases the number of distance calculations for each obstacle). For small obstacles and point obstacles, this value can be small (<10). Increase the value again if the trajectory is not smooth enough close to obstacles. 

      dynamic_obstacle_inflation_dist: 0.6
      include_dynamic_obstacles: True   #If set to true, the motion of obstacles with non-zero velocity (provided via user-supplied obstacles on topic ~/obstacles or obtained from the costmap_converter) is predicted and considered during optimization via a constant velocity model.

      legacy_obstacle_association: False  #False # The strategy of connecting trajectory poses with obstacles for optimization has been modified (see changelog). You can switch to the old/previous strategy by setting this parameter to true. Old strategy: for each obstacle, find the nearest TEB pose; new strategy: for each teb pose, find only "relevant" obstacles. 
      obstacle_association_force_inclusion_factor: 2.0  #1.5 # The non-legacy obstacle association strategy tries to connect only relevant obstacles with the discretized trajectory during optimization. But all obstacles within a specifed distance are forced to be included (as a multiple of min_obstacle_dist). E.g. choose 2.0 in order toenforce the consideration obstacles within a radius of 2.0*min_obstacle_dist. [This parameter is used only if parameter legacy_obstacle_association is false] 
      obstacle_association_cutoff_factor: 5.0 #5.0 # See obstacle_association_force_inclusion_factor, but beyond a multiple of [value]*min_obstacle_dist all obstacles are ignored during optimization. Parameter obstacle_association_force_inclusion_factor is processed first. [This parameter is used only if parameter legacy_obstacle_association is false] 
 
      costmap_converter_plugin: "costmap_converter::CostmapToPolygonsDBSMCCH"
      costmap_converter_spin_thread: True
      costmap_converter_rate: 5

      # Optimization
      
      no_inner_iterations: 5    #5
      no_outer_iterations: 4    #4
      optimization_activate: True
      optimization_verbose: False
      penalty_epsilon: 0.09  #0.1 #Add a small safety margin to penalty functions for hard-constraint approximations needs to be < max_vel_x
      obstacle_cost_exponent: 4.0
      weight_max_vel_x: 1.0   #1.0  #Optimization weight for satisfying the maximum allowed translational velocity 
      weight_max_vel_theta: 1.0   #Optimization weight for satisfying the maximum allowed angular velocity 
      weight_acc_lim_x: 0.0   #1.0  removed weight_acc_lim_* -> You can ignore acceleration limits by setting the weight to 0.0. By doing so the complexity of the optimization and hence the computation time can be reduced. 
      weight_acc_lim_y: 0.0
      weight_acc_lim_theta: 0.0 #1.0
      weight_kinematics_nh: 10.0    #reduce this significantly in order to adjust the tradeoff between compliant longitudinal motion and non-compliant lateral motion (strafing). 
      weight_kinematics_forward_drive: 200.0 #1.0 -> 30.0 #Optimization weight for forcing the robot to choose only forward directions (positive transl. velocities). A small weight (e.g. 1.0) still allows driving backwards. A value around 1000 almost prevents backward driving (but cannot be guaranteed). 
      weight_kinematics_turning_radius: 1.0
      weight_optimaltime: 0.1   #1.0 0.5- must be > 0 #Optimization weight for contracting the trajectory w.r.t transition/execution time 
      weight_shortest_path: 0.0
      weight_obstacle: 100.0  #Optimization weight for keeping a minimum distance from obstacles
      weight_inflation: 0.2   #0.1 #Optimization weight for the inflation penalty (should be small). 
      weight_dynamic_obstacle: 10.0 # not in use yet   
      weight_dynamic_obstacle_inflation: 0.2
      weight_viapoint: 50.0
      weight_adapt_factor: 2.0  #    Some special weights (currently weight_obstacle) are repeatedly scaled by this factor in each outer TEB iteration (weight_new = weight_old*factor). Increasing weights iteratively instead of setting a huge value a-priori leads to better numerical conditions of the underlying optimization problem. 

      # Homotopy Class Planner

      enable_homotopy_class_planning: True
      enable_multithreading: True
      max_number_classes: 2   #4  #Restrict the number of alternative trajectories that are subject to optimization. Often 2 alternatives are sufficient (avoid obstacle on the left or right side). 
      selection_cost_hysteresis: 1.0  #Specify how much trajectory cost must a new candidate have w.r.t. a previously selected trajectory in order to be selected (selection if new_cost < old_cost*factor). 
      selection_prefer_initial_plan: 1.0
      selection_obst_cost_scale: 100.0  #Extra scaling of obstacle cost terms just for selecting the 'best' candidate. 
      selection_alternative_time_cost: False #True #If true, time cost (sum of squared time differences) is replaced by the total transition time (sum of time differences). 

      roadmap_graph_no_samples: 15  #15 #Specify the number of samples generated for creating the roadmap graph 
      roadmap_graph_area_width: 6.0   #6.0  #Random keypoints/waypoints are sampled in a rectangular region between start and goal. Specify the width of that region in meters. 
      roadmap_graph_area_length_scale: 1.0  #Should be the factor multiplier to lenghten the distance from start-to goal, used to build the area where the sampling happens
      h_signature_prescaler: 1.0  #1.0 -> 0.5 #Scale internal parameter (H-signature) that is used to distinguish between homotopy classes. Warning: reduce this parameter only, if you observe problems with too many obstacles in the local cost map, do not choose it extremly low, otherwise obstacles cannot be distinguished from each other (0.2<value<=1). 
      h_signature_threshold: 0.1  #0.1 #Two H-signatures are assumed to be equal, if both the difference of real parts and complex parts are below the specified threshold. 
      obstacle_heading_threshold: 0.0  #1.0 ->0.2 #Specify the value of the scalar product between obstacle heading and goal heading in order to take them (obstacles) into account for exploration. 
      switching_blocking_period: 0.0  #0.0 #Specify a time duration in seconds that needs to be expired before a switch to a new equivalence class is allowed. 
      viapoints_all_candidates: True  #If true, all trajectories of different topologies are attached to the set of via-points, otherwise only the trajectory sharing the same topology as the initial/global plan is connected with them (no effect on test_optim_node)
      delete_detours_backwards: True    #True
      detours_orientation_tolerance: 1.57    #3.14
      max_ratio_detours_duration_best_duration: 5.0   #3.0 -> 5.0
      visualize_hc_graph: True   #False
      visualize_with_time_as_z_axis_scale: 0.0

      # Recovery
      
      shrink_horizon_backup: True   #    Allows the planner to shrink the horizon temporary (50%) in case of automatically detected issues (e.g. infeasibility). Also see parameter shrink_horizon_min_duration. 
      shrink_horizon_min_duration: 10.0
      oscillation_recovery: True
      oscillation_v_eps: 0.1
      oscillation_omega_eps: 0.1
      oscillation_recovery_min_duration: 10.0
      oscillation_filter_duration: 10.0

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 5.0
      global_frame: odom  #odom
      robot_base_frame: virtual_unicycle_base
      use_sim_time: True
      rolling_window: true
      width: 10    #3
      height: 10   #3
      resolution: 0.05
      robot_radius: 0.4
      track_unknown_space: false
      always_send_full_costmap: true
      trinary_costmap: true
      plugins:
      - obstacle_layer
      - voxel_layer
      - inflation_layer
      inflation_layer:
        plugin: nav2_costmap_2d::InflationLayer
        enabled: true
        inflation_radius: 2.0   #1.0
        cost_scaling_factor: 2.5
        inflate_unknown: false
        inflate_around_unknown: false
      obstacle_layer:
        plugin: nav2_costmap_2d::ObstacleLayer
        enabled: true
        observation_sources: scan
        footprint_clearing_enabled: true
        max_obstacle_height: 2.0
        combination_method: 1
        scan:
          topic: /filtered_scan_compensated
          obstacle_max_range: 20.0
          obstacle_min_range: 0.1
          raytrace_max_range: 25.0
          raytrace_min_range: 0.0
          max_obstacle_height: 2.0
          min_obstacle_height: 0.0
          clearing: true
          marking: true
          data_type: "LaserScan"
          inf_is_valid: false
      voxel_layer:
        plugin: nav2_costmap_2d::VoxelLayer
        enabled: true
        footprint_clearing_enabled: true
        max_obstacle_height: 2.0
        publish_voxel_map: true
        origin_z: 0.0
        z_resolution: 0.2
        z_voxels: 8
        unknown_threshold: 15
        mark_threshold: 2
        observation_sources: pointcloud_mark pointcloud_clear
        combination_method: 1
        pointcloud_mark:  # no frame set, uses frame from message
          topic: /camera_rgbd/depth/points
          max_obstacle_height: 2.0
          min_obstacle_height: 0.05
          obstacle_max_range: 5.0
          obstacle_min_range: 0.4
          raytrace_max_range: 6.0
          raytrace_min_range: 0.0
          clearing: false
          marking: true
          data_type: "PointCloud2"
        pointcloud_clear:  # no frame set, uses frame from message
          topic: /camera_rgbd/depth/points
          max_obstacle_height: 4.8
          min_obstacle_height: -4.8
          obstacle_max_range: 5.0
          obstacle_min_range: 0.0
          raytrace_max_range: 12.0
          raytrace_min_range: 0.0
          clearing: true
          marking: false
          data_type: "PointCloud2"
          
  local_costmap_client:
    ros__parameters:
      use_sim_time: True
  local_costmap_rclcpp_node:
    ros__parameters:
      use_sim_time: True

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 2.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: virtual_unicycle_base 
      use_sim_time: True
      robot_radius: 0.4
      resolution: 0.05
      trinary_costmap: true
      track_unknown_space: true
      plugins: 
      - static_layer
      - obstacle_layer
      - inflation_layer
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        footprint_clearing_enabled: True
        combination_method: 0
        observation_sources: scan
        scan:
          topic: /filtered_scan_compensated #filtered_scan_compensated
          max_obstacle_height: 2.0  #2.0
          min_obstacle_height: -1.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 20.0
          raytrace_min_range: 0.0
          obstacle_max_range: 6.0
          obstacle_min_range: 0.05
          inf_is_valid: False
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
        enabled: True
        subscribe_to_updates: True
        transform_tolerance: 0.2
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 2.5    #3.0
        inflation_radius: 1.0    #0.55
        inflate_unknown: false
        inflate_around_unknown: true
      always_send_full_costmap: True
  global_costmap_client:
    ros__parameters:
      use_sim_time: true
  global_costmap_rclcpp_node:
    ros__parameters:
      use_sim_time: true
#obstacle_layer:
      #  plugin: "nav2_costmap_2d::ObstacleLayer"
      #  enabled: True
      #  footprint_clearing_enabled: true
      #  observation_sources: pointcloud
      #  pointcloud:
      #    topic: /camera_rgbd/depth/points #/filtered_scan   #scan
      #    max_obstacle_height: 2.0
      #    min_obstacle_height: 0.1
      #    clearing: True
      #    marking: True
      #    data_type: "PointCloud2"
      #    obstacle_max_range: 6.0
      #    obstacle_min_range: 0.5   #can see the robots hands
      #    raytrace_max_range: 6.0
      #    raytrace_min_range: 0.0
      #voxel_layer:
      #  plugin: "nav2_costmap_2d::VoxelLayer"
      #  enabled: false
      #  publish_voxel_map: True
      #  origin_z: 0.0
      #  z_resolution: 0.05
      #  z_voxels: 16
      #  max_obstacle_height: 2.0
      #  mark_threshold: 0
      #  observation_sources: pointcloud
      #  scan:
      #    topic: /camera_rgbd/depth/points #/filtered_scan   #scan
      #    max_obstacle_height: 3.0
      #    clearing: True
      #    marking: True
      #    data_type: "PointCloud2"
      #    raytrace_max_range: 5.0
      #    raytrace_min_range: 0.0
      #    obstacle_max_range: 3.5
      #    obstacle_min_range: 0.0
map_server:
  ros__parameters:
    use_sim_time: True
    yaml_filename: "map.yaml"

map_saver:
  ros__parameters:
    use_sim_time: True
    save_map_timeout: 5.0
    free_thresh_default: 0.25
    occupied_thresh_default: 0.65
    map_subscribe_transient_local: true

planner_server:
  ros__parameters:
    planner_plugins: ['GridBased']
    use_sim_time: True
    expected_planner_frequency: 10.0   #20.0
    #GridBased:
    #  plugin: 'nav2_navfn_planner/NavfnPlanner'
    #  use_astar: True
    #  allow_unknown: False
    #  tolerance: 1.0
    GridBased:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      tolerance: 0.5                      # tolerance for planning if unable to reach exact pose, in meters, for 2D node
      downsample_costmap: false           # whether or not to downsample the map
      downsampling_factor: 1              # multiplier for the resolution of the costmap layer (e.g. 2 on a 5cm costmap would be 10cm)
      allow_unknown: false                # allow traveling in unknown space
      max_iterations: 1000000             # maximum total iterations to search for before failing (in case unreachable), set to -1 to disable
      max_on_approach_iterations: 1000    # maximum number of iterations to attempt to reach goal once in tolerance, 2D only
      max_planning_time: 3.5              # max time in s for planner to plan, smooth, and upsample. Will scale maximum smoothing and upsampling times based on remaining time after planning.
      motion_model_for_search: "DUBIN"    # For Hybrid Dubin, Redds-Shepp
      cost_travel_multiplier: 2.0         # For 2D: Cost multiplier to apply to search to steer away from high cost areas. Larger values will place in the center of aisles more exactly (if non-`FREE` cost potential field exists) but take slightly longer to compute. To optimize for speed, a value of 1.0 is reasonable. A reasonable tradeoff value is 2.0. A value of 0.0 effective disables steering away from obstacles and acts like a naive binary search A*.
      angle_quantization_bins: 64         # For Hybrid nodes: Number of angle bins for search, must be 1 for 2D node (no angle search)
      analytic_expansion_ratio: 3.5       # For Hybrid/Lattice nodes: The ratio to attempt analytic expansions during search for final approach.
      analytic_expansion_max_length: 3.0    # For Hybrid/Lattice nodes: The maximum length of the analytic expansion to be considered valid to prevent unsafe shortcutting (in meters). This should be scaled with minimum turning radius and be no less than 4-5x the minimum radius
      minimum_turning_radius: 0.30        # 0.4 For Hybrid/Lattice nodes: minimum turning radius in m of path / vehicle
      reverse_penalty: 2.1                # For Reeds-Shepp model: penalty to apply if motion is reversing, must be => 1
      change_penalty: 0.0                 # For Hybrid nodes: penalty to apply if motion is changing directions, must be >= 0
      non_straight_penalty: 1.20          # 1.2 For Hybrid nodes: penalty to apply if motion is non-straight, must be => 1
      cost_penalty: 2.0                   # For Hybrid nodes: penalty to apply to higher cost areas when adding into the obstacle map dynamic programming distance expansion heuristic. This drives the robot more towards the center of passages. A value between 1.3 - 3.5 is reasonable.
      retrospective_penalty: 0.025        # For Hybrid/Lattice nodes: penalty to prefer later maneuvers before earlier along the path. Saves search time since earlier nodes are not expanded until it is necessary. Must be >= 0.0 and <= 1.0
      rotation_penalty: 5.0               # For Lattice node: Penalty to apply only to pure rotate in place commands when using minimum control sets containing rotate in place primitives. This should always be set sufficiently high to weight against this action unless strictly necessary for obstacle avoidance or there may be frequent discontinuities in the plan where it requests the robot to rotate in place to short-cut an otherwise smooth path for marginal path distance savings.
      lookup_table_size: 20.0               # For Hybrid nodes: Size of the dubin/reeds-sheep distance window to cache, in meters.
      cache_obstacle_heuristic: True      # For Hybrid nodes: Cache the obstacle map dynamic programming distance expansion heuristic between subsiquent replannings of the same goal location. Dramatically speeds up replanning performance (40x) if costmap is largely static.  
      allow_reverse_expansion: False      # For Lattice nodes: Whether to expand state lattice graph in forward primitives or reverse as well, will double the branching factor at each step.   
      smooth_path: True                   # For Lattice/Hybrid nodes: Whether or not to smooth the path, always true for 2D nodes.
      smoother:
        max_iterations: 1000
        w_smooth: 0.3
        w_data: 0.2
        tolerance: 1e-10
        do_refinement: true               # Whether to recursively run the smoother 3 times on the results from prior runs to refine the results further

planner_server_rclcpp_node:
  ros__parameters:
    use_sim_time: True

recoveries_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    recovery_plugins: ["spin", "backup", "wait"]
    spin:
      plugin: "nav2_recoveries/Spin"
    backup:
      plugin: "nav2_recoveries/BackUp"
    wait:
      plugin: "nav2_recoveries/Wait"
    global_frame: odom
    robot_base_frame: virtual_unicycle_base #projection
    transform_timeout: 0.1
    use_sim_time: True
    simulate_ahead_time: 2.0
    max_rotational_vel: 0.2
    min_rotational_vel: 0.05
    rotational_acc_lim: 1.0

robot_state_publisher:
  ros__parameters:
    use_sim_time: True

waypoint_follower:
  ros__parameters:
    use_sim_time: True
    loop_rate: 2000
    stop_on_failure: false
    waypoint_task_executor_plugin: "wait_at_waypoint"   
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200

smoother_server:
  ros__parameters:
    use_sim_time: True
    smoother_plugins: ["simple_smoother"]
    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 1.0e-10
      max_its: 1000
      do_refinement: True

behavior_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    behavior_plugins: ["spin", "backup", "drive_on_heading", "wait"]
    spin:
      plugin: "nav2_behaviors/Spin"
    backup:
      plugin: "nav2_behaviors/BackUp"
    drive_on_heading:
      plugin: "nav2_behaviors/DriveOnHeading"
    wait:
      plugin: "nav2_behaviors/Wait"
    global_frame: odom
    robot_base_frame: virtual_unicycle_base #base_link
    transform_tolerance: 0.2  #0.1
    use_sim_time: true
    simulate_ahead_time: 2.0
    max_rotational_vel: 0.2   #1.0
    min_rotational_vel: 0.05   #0.1
    rotational_acc_lim: 1.0   #3.2